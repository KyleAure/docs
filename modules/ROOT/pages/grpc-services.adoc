// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description:
:seo-description:  
:page-layout: general-reference
:page-type: general
= Provide and consume gRPC services on Open Liberty

gRPC is an open source, universal remote procedural call (RPC) framework that can run in any environment and connects clients and services in language-agnostic way. You can provide and consume gRPC services from your web applications that run on Open Liberty.

== What is gRPC?

link:https://grpc.io/[gRPC ] is designed to efficiently connect microservices. It enables services and clients that use different networks, platforms and coding languages to call and implement functions through a common service definition contract. For example, you can create a gRPC service in Java with clients in Python and Go. Each application has to worry only about calling or implementing functions in its own language, gRPC handles the transmission of the calls and the generation of code in each language. gRPC makes use of link:https://developers.google.com/protocol-buffers/docs/reference/overview[protocol buffers] as its interface design language (IDL), allowing for simple service definitions. Its transport is built on top of HTTP/2, which supports high performance bidirectional connections.

Like other RPC frameworks, gRPC defines a service contract with explicit methods, parameters, and return types. On the server side, a server implements the service interface, which is defined in a protocol buffer `.proto` file. The client is provided with stubs that define the same interfaces that are provided by the server, so the
client application can invoke remote service methods as if they were local.





Developers can build and deploy new gRPC-enabled apps on Open Liberty to provide new gRPC services - or to consume external gRPC services. Support for gRPC can also be extended to existing Java EE web applications: well-established application logic can be exposed via a new gRPC service, or it can be extended to make use of a newer external service.

high-performance, open source, universal RPC framework that can run in any environment
what is RPC

gRPC clients and servers can run and talk to each other in a variety of environments — from servers inside Google, to your own desktop — and can be written in any of gRPC’s supported languages. For example, you can easily create a gRPC server in Java with clients in Go, Python, or Ruby.

gRPC is a modern RPC framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.

Efficiently connecting polyglot services in microservices style architecture
Connecting mobile devices, browser clients to backend services
Generating efficient client libraries


But when a monolith is broken down into multiple microservices, one big question remains -  how do these services talk to each other?

Protocol buffers an open source mechanism for serializing structured data. Protocol Buffers are a programming language independent architecture for Remote Procedure Calls.  Protocol Buffer Messages are defined and then compiled/code-generated into a developer's desired programming language (e.g. Java).  Developers can then use these Messages to transfer data structures between endpoints, even if the endpoint applications are written in different languages. Despite using two different programming languages, we can now have our greeter communicate from client to server in a standardized and language-agnostic way

At a very high level, let's imagine you have a Java service. You generate a gRPC service from the service definition and you have clients talking to that service (you can have a mobile client or a desktop client talking to the service here) through the stubs you’ve generated and all the connection details are abstracted. Then, your Java service could be talking to a Python service using a stub. In fact, it could happen that your Python service talks to two other services, let’s say a Go service and C++ service, again through stubs.

The beauty of this model is that communication between client and server, and between microservices, all happen through stubs that gRPC handles. Additionally, the other thing is the multilingual support (Java, Python). If you have different teams working on different languages - such as Python and Go and C++ from our example - it's not a problem, All they have to agree on is a service definition contract

gRPC makes it easy to build functions in code that can be separated by networks, programming languages, and even different types of compute resources. Instead of thinking about how to connect different services, we can build the services with a defined contract and write code to call/implement those functions. Using gRPC means services only need to be called by name—how to get to those services can be handled by transporting them over gRPC and coupling them into a network or service mesh.

== gRPC and Open Liberty

=== Application requirements

=== Application security with gRPC

=== Try it out

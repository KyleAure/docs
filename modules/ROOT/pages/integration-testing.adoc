// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
// This doc is hosted in the Red Hat Runtimes documentation. Any changes made to this doc also need to be made to the version that's located in the PurpleLiberty GitHub repo (https://github.com/PurpleLiberty/docs).
//
:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests by using Testcontainers framework for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests by using Testcontainers for Java microservice applications. With MicroShed testing, you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= True-to-production integration testing

Testcontainers is a Java library that facilitates the creation of integration tests that closely resemble production environments. It enables developers to test their applications within the same container used in production, thus reducing discrepancies between development and deployment settings.

By using the https://www.testcontainers.org/[Testcontainers] framework, developers can analyze their applications externally, without accessing internal application details. This approach ensures that integration tests accurately evaluate various test classes and components. Although integration tests require more setup and configuration time compared to unit tests, they provide a comprehensive assessment of the applicationâ€™s behavior in a realistic environment.

Unit tests focus on testing individual modules or components of an application and are quicker to run. Due to shorter development cycles and time constraints, developers often prioritize running unit tests. However, with Testcontainers, developers can efficiently write and run integration tests that closely resemble real-world production scenarios.

Testcontainers enables developers to create integration tests that closely resemble production environments. Integrating with the Testcontainers framework streamlines the process of writing and running true-to-production integration tests, enabling a more efficient workflow.

----
This will be removed

MicroShed Testing is a Java library that helps you write true-to-production integration tests for your application in an environment similar to production.
To minimize the parity issues between development and production, you can test your application in the same container that you use in production.

https://microshed.org/microshed-testing/[MicroShed Testing] uses the https://www.testcontainers.org/[Testcontainers] framework to analyze your application from outside the container without accessing the application internals.
You can use MicroShed Testing to develop integration tests for your Open Liberty application.

You need to make sure that your application works accurately in production, similar to the development environment.
Integration tests assess multiple test classes and components, but integration tests take longer to set up and configure than unit tests.
Alternatively, unit tests are shorter and involve testing individual modules of an application.
With shorter development cycles and limited time available, developers often run unit tests.
MicroShed Testing helps you write and run true-to-production integration tests for your applications, and streamlines your integration tests with the Testcontainers framework for an efficient workflow.
----

== Development and production parity

https://12factor.net/dev-prod-parity[Development and production parity] is one of the factors in the https://12factor.net/[twelve-factor app], which is a methodology to build modern applications.
The idea behind development and production parity is to keep the development, staging, and production environments similar, regarding time, personnel, and tools.
To simplify the development process, developers often use tools in development that are different from production.
For example, you might use a local Maven build to build a project for your application in development, but the application might be deployed to a container in production.
Differences between the environments can cause a test to fail in production, though the test passes in the development environment.
Testcontainers helps achieve development and production parity by testing the application in an environment similar to production.

----
This will be replaced

MicroShed Testing helps achieve development and production parity by testing the application in an environment similar to production.
----

== Writing integration tests with the Testcontainers framework

By using the Testcontainers framework, you can generate integration tests, and deploy your applications across various environments by using containers. Testcontainers offers a robust solution for creating and handling containers within a test environment. 
Designed for MicroProfile and https://jakarta.ee/[Jakarta EE] developers, Testcontainers serves as a Java library that facilitates the testing of applications within a production-like environment. It effectively enables developers to ensure development and production parity by thoroughly testing their applications in an environment that closely resembles the production setup.

----
This will be removed
== Writing integration tests with the Microshed Testing library

You can deploy your applications in different environments with containers.
With the Testcontainers framework, you can use containers in a test environment.
Microshed Testing is a Java library for MicroProfile and https://jakarta.ee/[Jakarta EE] developers to test their applications in an environment similar to production.
Microshed Testing implements the Testcontainers framework to support development and production parity in testing.
----

With Testcontainers, you can write an integration test. In the following example, Testcontainers are used to spin up a Docker container that is running an Open Liberty server with a test application deployed. It uses RestAssured to send HTTP requests to the service. This test case adds a person, retrieves all people, and verifies the correctness of the data.

```java

@Testcontainers
public class ServiceTest {

    // Latest liberty image
    static final DockerImageName libertyImage = DockerImageName.parse("open-liberty:23.0.0.4-full-java11-openj9");

    // Create container and copy application + server.xml
    @Container
    static final GenericContainer<?> liberty = new GenericContainer<>(libertyImage)
            .withExposedPorts(9080, 9443)
            .withCopyFileToContainer(MountableFile.forHostPath("build/libs/testapp.war"), "/config/dropins/testapp.war")
            .withCopyFileToContainer(MountableFile.forHostPath("build/resources/main/liberty/config/server.xml"), "/config/server.xml")
            .waitingFor(Wait.forLogMessage(".*CWWKZ0001I: Application .* started in .* seconds.*", 1))
            .withLogConsumer(new LogConsumer(ServiceTest.class, "liberty"));

    // Setup RestAssured query our service
    static RequestSpecification requestSpecification;

    @BeforeAll
    static void getServiceURL() {
        String baseUri = "http://" + liberty.getHost() + ":" + liberty.getMappedPort(9080) + "/testapp/people";
        requestSpecification = new RequestSpecBuilder()
                .setBaseUri(baseUri)
                .build();
    }

    // Run our test
    Jsonb jsonb = JsonbBuilder.create();
    @Test
    public void testAddPerson() {
        // Add new person to service
        given(requestSpecification)
            .header("Content-Type", "application/json")
            .queryParam("name", "bob")
            .queryParam("age", "24")
        .when()
            .post("/")
        .then()
            .statusCode(200);

        // Get and verify only one person exists
        List<Long> allIDs = given(requestSpecification)
            .accept("application/json")
        .when()
            .get("/")
        .then()
            .statusCode(200)
        .extract().body()
            .jsonPath().getList("id");

        assertEquals(1, allIDs.size());

        // Verify person is bob
        String actual = given(requestSpecification)
            .accept("application/json")
        .when()
            .get("/" + allIDs.get(0))
        .then()
            .statusCode(200)
        .extract().body()
            .jsonPath(x).getString("name");

        assertEquals("bob", actual);
    }
```

The `@Testcontainers` annotation indicates that this test class uses Docker containers for testing.

The `ServiceTest` class starts with a static field `libertyImage`, which represents the Docker image to be used for the test.

The liberty field is annotated with `@Container` and creates a Docker container by using the `libertyImage` image. It makes ports `9080` and `9443` accessible and copies the application and server configuration files into the container. It waits for a log message that indicates that the application started successfully and assigns a log consumer for logging container logs.

In the `@BeforeAll` annotated method `getServiceURL(), the base URL for the service is constructed by using the host and mapped port of the liberty container. The request specification is created with the base URL.

The `testAddPerson()` method is annotated with `@Test` and runs a series of tests on the service.

Inside the test method, a new person is added to the service by sending a POST request with JSON payload that contains the name and age parameters.

Upon adding the person, a GET request is sent to retrieve all people from the service. The response is validated to ensure a successful status code (200). The IDs of all the people are extracted from the response by using JSONPath.

The number of IDs is checked to ensure that only one person exists in the service.

Another `GET` request is sent to retrieve the details of the person with the extracted ID. The response is validated to ensure a successful status code `(200)`. The name of the person is extracted from the response by using JSONPath.

Finally, the extracted name is compared with the expected value `bob` using the `assertEquals()` method.

----

This will be removed

The `@MicroShedTest` annotation searches for a `Dockerfile` or `Containerfile` file in the repository, starts the application in a container, and waits for the application to be ready before the test starts.
The `@Container` annotation injects a REST Client proxy of the PersonService class, which helps you send HTTP requests on the running application container.
The `@RESTClient` annotation sends an HTTP POST request to the running container, which triggers the PersonService#createPerson endpoint and returns the generated ID.
By using the generated ID, you can send an HTTP GET request to read the record that was created.
The JSON response automatically converts to a Person object by using a JSON-B token.
The `@Test` annotation sends an HTTP GET request to find a Person object with the `-1` ID, which does not exist.
The annotation asserts that the application container returns an HTTP 404 exception.

----


== See also

Guide: https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]

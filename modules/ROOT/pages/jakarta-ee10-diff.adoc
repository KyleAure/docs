// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
// https://creativecommons.org/licenses/by-nd/4.0/
//
//
// Contributors:
// IBM Corporation
//
//
//
//
:page-description: If you are updating your application from using Jakarta EE 9.1 features to using Jakarta EE 10.1 features, certain changes in API behavior might require you to update your application code.
:projectName: Open Liberty
:page-layout: general-reference
:page-type: general
= Differences between Jakarta EE 10.0 and 9.1

If you are updating your application from using Jakarta EE 9.1 features to using Jakarta EE 10.0 features, changes in API behavior might require you to update your application code. These changes apply to the Jakarta Contexts and Dependency Injection (CDI) and Jakarta RESTful Web Services APIs and the Open Liberty features that support them.

The following sections describe updates for different Jakarta EE 10.0 features

* <<cdi,Jakarta Contexts and Dependency Injection 4.0>>
* <<restfulws,Jakarta RESTful Web Services 3.1>>
* <<servlet,Jakarta Servlet 6.0>>
* <<appAuthz,Jakarta Authorization 2.1>>
* <<appAuthn,Jakarta Authentication 3.0>>

[#cdi]
== Differences between Jakarta Contexts and Dependency Injection 4.0 and 3.0

Although Open Liberty xref:zero-migration-architecture.adoc[zero migration] architecture simplifies migrating your server configuration between versions, the following changes might require updates to relevant application code. CDI 4.0 introduces Build Compatible Extensions, observable container state events, and changes how empty and unversioned `beans.xml` files are handled. Several previously deprecated APIs are removed in this release.

=== Build Compatible Extensions

CDI provides Portable Extensions to customize the CDI application initialization lifecycle. In CDI 4.0, Build Compatible Extensions make implementing extensions amenable to build-time processing. To implement a build compatible extension, provide an implementation of the `BuildCompatibleExtension` interface that is declared in the  `META-INF/services` directory. The implementation can provide methods that are annotated with one of the following extension annotations, each of which corresponds to an extension execution phase.

* `@Discovery`
* `@Enhancement`
* `@Registration`
* `@Synthesis`
* `@Validation`

For example, as part of the `Enhancement` phase, the implementation in the following example adds a `MyQualifier` annotation to the `MyService` type.

[source,java]
----
public class MyExtension implements BuildCompatibleExtension {
    @Enhancement(type=MyService.class)
    public void addMyQualifier(ClassConfig clazz) {
        clazz.addAnnotation(MyQualifier.class)
    }
}
----

=== Startup and Shutdown events

Two new observable container state events are available in CDI 4.0: `Startup` and `Shutdown`. Applications can listen for these events to be notified when the CDI container is starting up and being shut down. The following example listens for `Startup` and `Shutdown` events and prints a notification for each to the console when it receives the event.

[source,java]
----
@ApplicationScoped
public class MyObserver {
    public void observeStartup(@Observes Startup startupEvent) { {
        System.out.println("CDI Container is starting");
    }

    public void observeShutdown(@Observes Shutdown shutdownEvent) { {
        System.out.println("CDI Container is stopping");
    }
}
----

You can control the order among multiple observable container state methods by using the `@Priority` annotation.

=== Empty beans.xml files

In previous versions of CDI, an archive that contained an empty `beans.xml` file was treated as an explicit bean archive, the equivalent of setting the `bean-discovery-mode="all"` attribute in the file. In CDI 4.0, an empty `beans.xml` file causes an archive to be treated as an implicit bean archive, the equivalent of setting the `bean-discovery-mode="annotated"` attribute in the file. If necessary, you can <<cdiConfiguration, set the emptyBeansXmlCDI3Compatibility attribute>> to enable compatibility with previous versions. If you set this attribute to `true` in CDI 4.0, any archives that contain an empty `beans.xml` file are treated as explicit beans archives.

=== Unversioned beans.xml files

In previous versions of CDI, a nonempty `beans.xml` file that did not include a `version` attribute defaulted to the `bean-discovery-mode="all"` attribute. In CDI 4.0, it defaults to the `bean-discovery-mode="annotated"` attribute. Therefore, by default, only objects with CDI bean-defining annotations are discovered as CDI beans. However, always properly specify a version for all `beans.xml` files, as shown in the following example.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_4_0.xsd"
    version="4.0"
    bean-discovery-mode="annotated">
</beans>
----

=== Programmatic lookup of beans and instances

In CDI 4.0, a new Handle API is available to simplify programmatic inspection of bean metadata. This API avoids the need to create instances before they are required. You can obtain a `Handle`  instance by using the Instance API, as shown in the following example.

[source,java]
----
public interface Handle<T> extends AutoCloseable {
        T get();
        Bean<T> getBean();
        void destroy();
        void close();
}
----

=== Removed APIs

The following previously deprecated CDI APIs are removed in CDI 4.0.

* `@New` qualifier, which replaced by `@Dependent` beans.
* `Bean#isNullable()`, not used by the implementation since CDI 1.1.
* `BeanManager#createInjectionTarget(AnnotatedType)`, replaced by `BeanManager#getInjectionTargetFactory(AnnotatedType)`
* `BeforeBeanDiscovery#addAnnotatedType(AnnotatedType)`, replaced by `BeforeBeanDiscovery#addAnnotatedType(AnnotatedType, String)`

[#cdiConfiguration]
=== Server.xml configuration element and attribute updates
In the Liberty feature:cdi-4.0[display=Jakarta Contexts and Dependency Injection 4.0] feature, the config:cdi12[] configuration element is superseded by the config:cdi[] element, which applies to CDI versions 1.2 and later. The following `server.xml` file example shows the element with two attributes that are specified.

[source,xml]
----
<cdi enableImplicitBeanArchives="false" emptyBeansXmlCDI3Compatibility="true"/>
----

The `enableImplicitBeanArchives` attribute is the same as it was in previous versions.
If this attribute is set to `true`, which is the default, then archives with no `beans.xml` file are treated as implicit bean archives and scanned for classes that have bean defining annotations.
If this attribute is set to `false`, then archives that do not contain a `beans.xml` file are not scanned for annotated classes.

The `emptyBeansXmlCDI3Compatibility` attribute applies only to CDI 4.0.
If this attribute is set to `true`, an archive that contains an empty `beans.xml` file is treated as an explicit bean archive, as it was in CDI 3.0 and earlier.
If this attribute set to `false`, which is the default, then an archive that contains an empty `beans.xml` file is treated as an implicit bean archive.

For more information, see the https://jakarta.ee/specifications/cdi/4.0/apidocs/[Jakarta Contexts and Dependency Injection 4.0 Javadoc]

[#restfulws]
== Differences between Jakarta RESTful Web Services 3.1 and 3.0

[#servlet]
== Differences between Jakarta Servlet 6.0 and 5.0

The feature:servlet-6.0[display=Jakarta Servlet 6.0] feature provides new APIs and new configurations to set any attribute on a response cookie.

=== New ways to configure cookie attributes

In Jakarta Servlet 6.0, you can set attributes on a response cookie either in deployment descriptor file, programmatically with the `jakarta.servlet.ServletContainerInitializer` API, or at request time.

You can set cookie attributes in a `web.xml` deployment descriptior file by specifying the `attribute` element within the `cookie-config` element, as shown in the following example.

[source,xml]
----
<session-config>
   <cookie-config>
     <name>SampleCookieName</name>
     <domain>my.domain.com</domain>
     <path>/</path>
     <http-only>true</http-only>
     <secure>true</secure>
     <attribute>
        <attribute-name>MyAttributeName</attribute-name>
        <attribute-value>valueExample</attribute-value>
     </attribute>
     <attribute>
        <attribute-name>MyOtherAttribute</attribute-name>
        <attribute-value>OtherValue</attribute-value>
     </attribute>
   </cookie-config>
</session-config>
----

You can also set cookie attributes dynamically from an application during application startup by using the `jakarta.servlet.ServletContainerInitializer` API, as shown in the following example.

[source,java]
----
@Override
public void onStartup(Set<Class<?>> setOfClasses, ServletContext context) throws ServletException {
      SessionCookieConfig scc = context.getSessionCookieConfig();
      scc.setName("MyDynaCookieName");
      scc.setAttribute("MyDynamicAttribute", "DynamicValue");
      ..........
}
----

Alternatively, you can set attributes from the application at request time, as shown in the following example.

[source,java]
----
SessionCookieConfig scc = getServletContext().getSessionCookieConfig();
scc.setName("MyRequestCookieName");
scc.setAttribute("MyRequestAttribute", "RequestValue");
----

If conflicts arise among different sources for the cookie configuration, the following precedence order applies to resolve the conflict, from highest to lowest precedence.

. Attributes that are set by the application at request time
. Attributes that are set by the application by using the `ServletContainerInitializer` API
. Attributes that are set in the `web.xml` deployment descriptor file


=== Changes to the request cookie header

Servlet 6.0 implements the HTTP request cookie behavior by following the https://www.rfc-editor.org/rfc/[rfc6265] standard, which states that HTTP client agents such as browsers do not send back cookie attributes to the application server.

Previously, you could include request cookie attributes by adding the dollar sign (`$`) as a prefix to a valid attribute name. For example, `$Domain=myDomain.com` was treated as the `Domain` attribute for the request cookie. Starting in Servlet 6.0, `$Domain` is treated as a new cookie that is named `$Domain`. The dollar sign is also part of the cookie name. The only exception to this rule is the  `$Version` value.

For example, consider the following HTTP request that includes a cookie header.

----
Cookie: $Version=1; name1=value1; $Path=/Dollar_Path; $Domain=localhost; $NAME2=DollarNameValue;Domain=DomainValue
----

Before Servlet 6.0, the server creates the following three request cookies.

----
cookie1: name1 with the associated attributes: Path=/Dollar_Path; Domain=localhost
cookie2: NAME2
cookie3: Domain
----

In Servlet 6.0 and later, the server creates the following five request cookies from the same HTTP request.

----
cookie1: name1
cookie2: $Path
cookie3: $Domain
cookie4: $NAME2
cookie5: Domain
----

=== Application debug enhancements

New `jakarta.servlet.ServletRequest` APIs and new a new `jakarta.servlet.ServletConnection` class are available to help you debug requests to your application. With the enhancement, you can track or refer to a request or obtain details of the network connection that is used by the request by using the request ID.

The following `Jakarta.servlet.ServletRequest` APIs are available in Servlet 6.0.

* `String getRequestId()`
* `String getProtocolRequestId()`
* `ServletConnection getServletConnection()`

A new `jakarta.servlet.ServletConnection` object is retrieved from the `getServletConnection()` servlet request. It includes the following APIs.

* `String getConnectionId()`
* `String getProtocol()`
* `String getProtocolConnectionId()`
* `boolean isSecure()`

=== Removed APIs and classes

The following previously deprecated APIs are removed.

* `jakarta.servlet.ServletContext` - `Servlet getServlet(String)`, `Enumeration<Servlet> getServlets()`, `Enumeration<String> getServletNames()`, `void log(Exception, String)`
* `jakarta.servlet.ServletRequest` - `String getRealPath(String)`
* `jakarta.servlet.ServletRequestWrapper` - `String getRealPath(String)`
* `jakarta.servlet.UnavailableException` - `UnavailableException(Servlet, String)`, `Servlet getServlet()`
* `jakarta.servlet.http.HttpServletRequest` - `boolean isRequestedSessionIdFromUrl()`
* `jakarta.servlet.http.HttpServletRequestWrapper` - `boolean isRequestedSessionIdFromUrl()`
* `jakarta.servlet.http.HttpServletResponse` - `String encodeUrl(String)`, `String encodeRedirectUrl(String)`, `void setStatus(int, String)`
* `jakarta.servlet.http.HttpServletResponseWrapper` -  `String encodeUrl(String)`, `String encodeRedirectUrl(String)`, v`oid setStatus(int, String)`
* `jakarta.servlet.http.HttpSession` - `HttpSessionContext getSessionContext()`, `Object getValue(String)`, `String[] getValueNames()`, `void putValue(String, Object)`, `void removeValue(String)`

The following previously deprecated classes are removed.

* `jakarta.servlet.SingleThreadModel`
* `jakarta.servlet.http.HttpSessionContext`
* `jakarta.servlet.http.HttpUtils`

For more information, see the https://jakarta.ee/specifications/servlet/6.0/apidocs/jakarta.servlet/module-summary.html[Jakarta Servlet 6.0 Javadoc].

[#appAuthz]
== Differences between Jakarta Authorization 2.1 and 2.0

The feature:appAuthorization-2.1[display=Jakarta Authorization 2.1] feature (`appAuthorization-2.1`) feature introduces the following new methods.

=== New methods for the jakarta.security.jacc.PolicyConfigurationFactory abstract class

The `jakarta.security.jacc.PolicyConfigurationFactory` abstract class implements the following two
new methods to  retrieve the Policy Configuration interface (`PolicyConfiguration`).

* `public abstract PolicyConfiguration getPolicyConfiguration();`
* `public abstract PolicyConfiguration getPolicyConfiguration(String contextID);`

The methods are available in addition to the following method that was available in previous versions.

`public abstract PolicyConfiguration getPolicyConfiguration(String contextID, boolean remove);`

=== New methods for the `jakarta.security.jacc.PolicyConfiguration` interface

The `jakarta.security.jacc.PolicyConfiguration` interface defines three new methods to read
permissions.

* `public abstract Map<String, PermissionCollection> getPerRolePermissions();`
* `public abstract PermissionCollection getUncheckedPermissions();`
* `public abstract PermissionCollection getExcludedPermissions();`

For more information, see the https://jakarta.ee/specifications/authorization/2.1/apidocs/jakarta.security.jacc/jakarta/security/jacc/package-summary.html[Jakarta Authorization 2.1 Javadoc].

[#appAuthn]
== Differences between Jakarta Authentication 3.0 and 2.0

The feature:appAuthentication-2.1[display=Jakarta Authentication 3.0] feature (`appAuthentication-3.0`) feature introduces changes to the`jakarta.security.auth.message.config.AuthConfigFactory` abstract class. This class implements two new methods to register and remove a server authentication module. Before this version of the feature, support was available only to register and remove a configuration provider.

* `public abstract String registerServerAuthModule(ServerAuthModule serverAuthModule, Object context);`
* `public abstract void removeServerAuthModule(Ojbect context);`

For more information, see the https://jakarta.ee/specifications/authentication/3.0/apidocs/jakarta.security.auth.message/module-summary.html[Jakarta Authentication Javadoc].

== See also

* xref:jakarta-ee.adoc[Jakarta EE overview]

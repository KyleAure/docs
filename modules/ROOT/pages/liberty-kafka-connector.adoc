// Copyright (c) 2024 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//    https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
// IBM Corporation
//
:page-layout: general-reference
:page-type: general
:page-description: The integration of MicroProfile Reactive Messaging with Apache Kafka in Open Liberty applications is a significant development in cloud-native microservice designs as it provides an efficient method of asynchronous communication.
:page-categories: MicroProfile Reactive Messaging
:seo-title: Integrating MicroProfile Reactive Messaging with Apache Kafka in Open Liberty Applications
:seo-description: The integration of MicroProfile Reactive Messaging with Apache Kafka in Open Liberty applications is a significant development in cloud-native microservice designs as it provides an efficient method of asynchronous communication.

= Optimizing Kafka Integration with MicroProfile Messaging

Integrating MicroProfile Reactive Messaging with Apache Kafka in Open Liberty applications is a significant development in cloud-native microservice designs as it provides an efficient asynchronous communication method.

MicroProfile Reactive Messaging allows applications to manage data flow reactively across microservices that help the systems to scale and remain resilient. Apache Kafka is a distributed event-streaming platform that boosts this environment by offering a reliable platform for high-throughput, fault-tolerant event streaming, crucial for event-driven architectures.

By integrating these technologies through the `liberty-kafka` connector in Open Liberty, you gain a comprehensive overview of setting up, configuring, and optimizing the `liberty-kafka` connector. It enables the use of Kafka’s capabilities within a MicroProfile Reactive Messaging framework to build robust and efficient microservices.

The core aspects of integrating MicroProfile Reactive Messaging with Apache Kafka in Open Liberty, detailed through the following topics:

* <<#lkconnector,Liberty-kafka connector>>
* <<#configuration,Configuration>>
* <<#kcconfsec,Kafka connector configuration and security>>
* <<#sendrecemessages,Sending and receiving messages between applications by using connectors>>
* <<#connectoroptionschannelprop,Connector options and channel properties>>
* <<#troubleshooting,Troubleshooting>>


[#lkconnector]
== Liberty-kafka connector

The `liberty-kafka` connector feature within Open Liberty facilitates seamless integration with Apache Kafka, enabling applications to send and receive messages from an Apache Kafka broker. It uses MicroProfile Reactive Messaging standards for robust, asynchronous communication in microservices architectures. 

You can fine-tune your application's interaction with Kafka by configuring the connector in the `microprofile-config.properties` file, as shown in the following example.

----
mp.messaging.connector.liberty-kafka.bootstrap.servers=localhost:9082
----

You can define a channel to use this connector, directly linking a message channel to Kafka, as shown in the following example.

----
mp.messaging.incoming.myChannel.connector=liberty-kafka
----

By setting up a channel as shown in the example, you connect a message channel directly to Kafka. Giving you precise control over the messaging channels. You can specify attributes such as `bootstrap.servers` for connection and `topic` for message direction, enhancing your application's ability to scale and remain robust by efficiently managing messages.


[#configuration]
== Configuration

To configure the `Liberty-kafka` connector effectively, follow these steps:

1. Configure Kafka Broker Connection
+
In the `microprofile-config.properties` file, specify the Kafka broker addresses to establish a connection. Indicating where your Kafka broker is hosted.
+
----
mp.messaging.connector.liberty-kafka.bootstrap.servers=myKafkaBroker:9092
----
+
2. Define Channels for Messaging
+
* To specify the Kafka topic from which messages are received, create a channel for incoming messages.
----
mp.messaging.incoming.myChannel.connector=liberty-kafka
mp.messaging.incoming.myChannel.topic=myTopicName
----
* To specify the Kafka topic from which messages are sent, create a channel for outgoing messages.
----
mp.messaging.outgoing.myChannel.connector=liberty-kafka
mp.messaging.outgoing.myChannel.topic=myTopicName.
----
+
3. Include Kafka Client Libraries

To integrate Kafka into your application environment by using Open Liberty, choose one of the following methods based on your requirement.

* Include Kafka Libraries as an Application Dependency

To use the Kafka connector provided by Open Liberty, you must include the Kafka client API jar in your application.

If you are building your application with Maven, add the Kafka client dependency in your Maven `pom.xml` file.

[source,XML]
----
<dependency>
    <groupId>org.apache.kafka</groupId>
    <artifactId>kafka-clients</artifactId>
    <version>3.5.1</version>
</dependency>
----

This approach integrates Kafka client libraries directly into your application. It does not require any additional server configuration for permissions, simplifying deployment and configuration management.

* Include Kafka Libraries as a Shared Library

Kafka client libraries can be integrated as a shared resource within the Open Liberty server. This approach is useful for situations where several applications on the same server instance require the Kafka client libraries. It effectively minimizes duplication.

However, if Kafka client libraries are used as a shared library, you must explicitly grant the necessary Java permissions for the libraries to function correctly. These permissions allow the Kafka client to connect to Kafka brokers, read system properties, and access or modify security properties.

To configure these permissions, you can use the `server.xml` configuration file. The following example demonstrates how to grant the necessary permissions to the Kafka client library specified as a shared library:

[source,XML]
----
    <variable name="kafkaCodebase" value="${server.config.dir}/kafkaLib/kafka-clients-<client.version>.jar"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanServerPermission" name="createMBeanServer"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanPermission" name="*" actions="*"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanTrustPermission"name="register"/>
   
   <!-- Kafka client reads system properties -->
   <javaPermission codebase="${kafkaCodebase}" className="java.util.PropertyPermission"name="*"actions="read"/>
   
   <!-- Kafka client connects to the kafka broker server -->
   <javaPermission codebase="${kafkaCodebase}" className="java.net.SocketPermission"name="*"actions="connect"/>
   
   <!-- Kafka client loads serializers and deserializers by name -->
   <javaPermission codebase="${kafkaCodebase}" className="java.lang.RuntimePermission"name="getcodebase="${kafkaCodebase}" classLoader"actions="*"/>
   
   <!-- Kafka reads truststores -->
   <javaPermission codebase="${kafkaCodebase}" className="java.io.FilePermission" name="*" <!-- all files in the current directory (i.e. the server directory) --> actions="read"/>
   
   <!-- Kafka client allowed to invoke the Subject.doAs methods -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="doAs"/>
   
   <!-- Kafka client allowed to call getSubject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="getSubject"/>
   
   <!-- Kafka client sets properties for the Simple SASL/PLAIN Server Provider -->
   <javaPermission codebase="${kafkaCodebase}" className="java.security.SecurityPermission" name="putProviderProperty.Simple SASL/PLAIN Server Provider"/>
   
   <!-- Kafka client allowed to set a Provider -->
   <javaPermission codebase="${kafkaCodebase}" className="java.security.SecurityPermission" name="insertProvider"/>
   
   <!-- Kafka client allowed access to private Credentials belonging to a particular Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.PrivateCredentialPermission" name="* * "*"" actions="read"/>
   
   <!-- Kafka client allowed to modify the set of public credentials associated with a Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="modifyPublicCredentials"/>
   
   <!-- Kafka client allowed to modify the set of private credentials associated with a Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="modifyPrivateCredentials"/>
----


[#kcconfsec]
== Kafka connector configuration and security

For configuring the Kafka connector and security in Open Liberty, you can focus on the distinction between channel-specific and connector-wide properties for tailored messaging behavior. 

Connector-wide properties, like `bootstrap.servers` apply globally, whereas channel-specific properties, such as `topic` or `group.id`, customize the individual channel behavior. 

For security, Open Liberty supports multiple authentication methods: 

* Basic Authentication
* SASL_Plain
* SASL_SSL
* Mutual TLS

To make sure of secure communication with Kafka brokers, you set the appropriate security properties within the `microprofile-config.properties` file, facilitating the support of various authentication methods.


[#sendrecemessages]
== Sending and receiving messages between applications by using connectors

To send and receive messages from other systems, reactive messaging uses connectors. Connectors can be attached to one end of a channel and are configured by using MicroProfile Config. Open Liberty includes the `liberty-kafka` connector for sending and receiving messages from an Apache Kafka broker.

The following example shows you how to configure a microservice for retrieving messages from a Kafka topic, which is achieved by using MicroProfile (MP) Reactive Messaging and a Kafka connector.
----
mp.messaging.incoming.foo.connector=liberty-kafka
mp.messaging.incoming.foo.bootstrap.servers=kafkabrokerhost:9092
mp.messaging.incoming.foo.group.id=foo-reader
mp.messaging.incoming.foo.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
mp.messaging.incoming.foo.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
----

The example indicates the `liberty-kafka` connector type for the incoming channel `foo`. The `kafkabrokerhost:9092` Kafka broker address, the `foo-reader` consumer group ID, and the deserializers for both `key` and `value` are `org.apache.kafka.common.serialization.StringDeserializer`, indicating that both keys and values are expected to be strings.

This configuration is essential for retrieving messages from the specified topic, facilitating the building of reactive applications that can efficiently process data streams.

Similarly, the following example of how to set up a microservice to send messages to a Kafka broker.
----
mp.messaging.outgoing.bar.connector=liberty-kafka
mp.messaging.outgoing.bar.bootstrap.servers=kafkabrokerhost:9092
mp.messaging.outgoing.bar.key.serializer=org.apache.kafka.common.serialization.StringSerializer
mp.messaging.outgoing.bar.value.serializer=org.apache.kafka.common.serialization.StringSerializer
----

The example indicates the use of the `liberty-kafka` connector for managing the connection between the application and Kafka. The `bootstrap.servers` setting points to `kafkabrokerhost:9092`, the Kafka broker's network address, allowing the application to locate and send messages to the Kafka cluster. The `key` and `value` of messages are configured to use `StringSerializer`. The application serializes both parts of the message as strings for Kafka transmission.

The application gains the ability to offload messages to the Kafka topic `bar`. This approach to distributed messaging enhances scalability and flexibility in handling data flows.


[#connectoroptionschannelprop]
== Connector options and channel properties

The `Liberty-kafka` connector offers a range of properties to fine-tune its operation. You can set these properties on the `Liberty-kafka` connector to define certain behaviors during operation.

You can use all these options as attributes on either the connector or a channel that uses the `Liberty-kafka` connector. If you specify the option on both the channel and the connector, the channel takes precedence.


.Properties supported by the `liberty-kafka` connector for incoming channels
[cols="a,a,a",width="100%"]
|===
|Property Name |Default |Description

|topic
|The name of the channel.
|The Kafka topic that the channel is to either send or receive messages from.

|unacked.limit
|Defaults to the value of `max.poll.records` if set, or to 500.
|The number outstanding unacknowledged messages. 
 {empty} +
 If this limit is reached, the connector stops retrieving records from Kafka until some messages are acknowledged.

|fast.ack
|- MicroProfile Reactive Messaging 1.0 - `False`
 {empty} +
 - MicroProfile Reactive Messaging 3.0 - `true`
|Defines the acknowledge behavior of the `liberty-kafka` connector within the MicroProfile Reactive Messaging framework for `incoming` channels in relation to activities with the Kafka topic.
 {empty} +
If the value of `fast.ack` is `false`, the acknowledgment is not reported as complete until the partition offset is committed to the Kafka broker. If an error occurs during this process, then the acknowledgment is reported as failed.
 {empty} +
If the value of `fast.ack` is `true`, and the acknowledgment is reported as complete when the Kafka Connector receives the acknowledgment signal.

|context.service
|If the `concurrent-x.y` feature is enabled. the default context service is used.
 {empty} +
 If the concurrent feature is not enabled, the built in Liberty context service is used with a set list of context types to capture and apply around asynchronous tasks.
|Enabling the concurrent feature is needed for the `context.service` option to be effective for the `liberty-kafka` connector. 
 {empty} +
This setting specifies the Context Service that is used for Asynchronous tasks.

|
|Uses the Kafka Client default
|All other properties are passed directly as config parameters to the KafkaConsumer API. A list of required and optional properties can be found in the http://kafka.apache.org/documentation.html#consumerconfigs[Kafka documentation].

|===



.Properties supported by the `liberty-kafka` connector for outgoing channels
[cols="a,a,a",width="100%"]
|===
|Property Name |Default |Description

|topic
|The name of the channel.
|The Kafka topic that the channel is to either send or receive messages from.


|context.service
|If the `concurrent-x.y` feature is enabled. the default context service is used.
 {empty} +
 If the concurrent feature is not enabled, the built in Liberty context service is used with a set list of context types to capture and apply around asynchronous tasks.
|Enabling the concurrent feature is needed for the `context.service` option to be effective for the `liberty-kafka` connector. 
 {empty} +
This setting specifies the Context Service that is used for Asynchronous tasks.

|
|Uses the Kafka Client default
|All other properties are passed directly as config parameters to the KafkaProducer API. A list of required and optional properties can be found in the http://kafka.apache.org/documentation.html#producerconfigs[Kafka documentation].

|===


=== fast.ack
Properties like `fast.ack` allow for control over message acknowledgment processes, improving the efficiency of message processing. 

In the following example, in the `microprofile-config.properties` file of the application, the `fast.ack` setting is defaulted to `false` for the connector, affecting all channels in the application. However, for a distinct incoming channel called `foo`, this setting is overridden to `true`. This alteration favors a quicker acknowledgment approach, which enhances the handling performance for messages that arrive on this channel.

----
mp.messaging.connector.liberty-kafka.fast.ack=false

mp.messaging.incoming.foo.connector=liberty-kafka
mp.messaging.incoming.foo.fast.ack=true
----

=== context.service
The `context.service` attribute specifies the Context Service for asynchronous operations, critical for performance tuning. 

Context Services that are defined within the application itself cannot be used with the `liberty-kafka` connector. 

In the following example, the `server.xml` file defines three different context services, each with a unique identifier (`rst`, `uvw`, and `xyz`).

server.xml
----
<contextService id=“rst”/>
<contextService id=“uvw”/>
<contextService id=“xyz”/>
----

The `microprofile-config.properties` file is part of the application's configuration and specifies how MicroProfile features should be used within the application.

microprofile-config.properties
----
mp.messaging.connector.liberty-kafka.context.service=rst

mp.messaging.incoming.def.connector=liberty-kafka
mp.messaging.incoming.foo.connector=liberty-kafka
mp.messaging.incoming.foo.context.service=uvw
mp.messaging.outgoing.bar.connector=liberty-kafka
mp.messaging.outgoing.bar.context.service=xyz
----

The property `mp.messaging.connector.liberty-kafka.context.service=rst` indicates that the Kafka connector that is used for handling messaging between services uses the `rst`` context service by default for its operations.

The application has three channels (`def`, `foo`, and `bar`), which are logical endpoints for incoming and outgoing messages. The configuration for these channels specifies which Kafka connector to use (`liberty-kafka`) and for two of the channels (`foo` and `bar`), overrides the default context service with their own (`uvw` and `xyz`, respectively).

The `def` channel does not specify its own `context.service`, so it inherits the default one (`rst`) defined at the connector level.

By defining separate context services, the application can isolate certain operations or configurations, which can be useful in complex applications or during integration with external systems.

These configurations demonstrate the flexibility and control that you have over message processing in Open Liberty applications.

[#troubleshooting]
== Troubleshooting

For troubleshooting the `Liberty-kafka` connector, you can focus on resolving common issues such as connectivity with Kafka, managing multiple server instances, and assigning distinct identifiers to producers and consumers. 

Proper configuration of `bootstrap.servers` properties is crucial for connectivity. Use a distinct `group.id` for each consumer in different instances to avoid conflicts, and assign a distinct `client.id` for producers to prevent identifier overlap.

=== Multiple server instances

If multiple instances of Open Liberty are started with the same application, it is essential to specify a distinct `group.id` for each channel on every server instance for all incoming channels. Without a distinct `group.id` on each server instance, the server rejects any additional connections to a topic beyond the first one. This requirement makes sure that each connection to a topic is uniquely identified and managed across server instances.

=== Multiple Reactive Messaging applications using the same Kafka server

Deploying multiple applications with a Kafka client to Liberty, all connecting to the same Kafka server, can cause errors. These errors stem from conflicting identifiers that are used by both Kafka Producers and Consumers within the applications.

This is due to how Kafka generates the `client.id` for both. Consumers generate identifiers based on their `group.id` or their `client.id`.

- For consumers, it is suggested that you create a distinct `group.id` for each incoming channel.

- For producers, it is suggested that you create a distinct `client.id` for each outgoing channel.

Specifying either attribute on the `liberty-kafka` Connector does not resolve the issue and is not advised.

These steps are designed to diagnose and resolve common challenges that are encountered integrating Kafka with Open Liberty. They help in facilitating the smooth functioning of your microservices architecture.

For more information on Apache Kafka, see the https://kafka.apache.org/documentation.html#gettingStarted[Apache Kafka documentation].











// Copyright (c) 2024 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//    https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
// IBM Corporation
//
:page-layout: general-reference
:page-type: general
:page-description: Integrating MicroProfile Reactive Messaging and Apache Kafka with the Liberty-Kafka connector provides an efficient asynchronous communication method for Open Liberty applications. This setup helps you handle large volumes of data efficiently, which is essential for event-driven systems.
:page-categories: MicroProfile Reactive Messaging
:seo-title: Optimizing asynchronous communication with MicroProfile Reactive Messaging
:seo-description: Integrating MicroProfile Reactive Messaging and Apache Kafka with the Liberty-Kafka connector provides an efficient asynchronous communication method for Open Liberty applications. This setup helps you handle large volumes of data efficiently, which is essential for event-driven systems.

= Optimizing asynchronous communication with MicroProfile Reactive Messaging

Integrating MicroProfile Reactive Messaging and Apache Kafka with the Liberty-Kafka connector provides an efficient asynchronous communication method for Open Liberty applications. This setup helps you handle large volumes of data efficiently, which is essential for event-driven systems.

In highly distributed and event-driven application architectures, it is critical to manage data transfer between system components in a nonobstructive and responsive manner. Reactive messaging patterns make it possible by enabling applications to send, receive, and process messages asynchronously. By decoupling system components, this method enhances scalability and resilience. Open Liberty incorporates this paradigm with its MicroProfile Reactive Messaging support. By using MicroProfile Config properties to configure reactive messaging channels in Open Liberty, it is possible to facilitate the administration and specification of how your applications interact with message brokers like Kafka. By configuring this setting, you can precisely tailor the behavior of reactive messaging to the requirements of your application, which ensures streamlined data processing and communication. For more information on the the MicroProfile Reactive Messaging properties, see xref:microprofile-config-properties.adoc#react[MicroProfile Config properties for MicroProfile Reactive Messaging].

The following section describes how to intergrate MicroProfile Reactive Messaging with Apache Kafka to send messages within and between applications.

[#configuration]
== Configure the Liberty-Kafka connector

The Liberty-Kafka connector enables applications to send and receive messages from an https://kafka.apache.org/[Apache Kafka broker]. It uses MicroProfile Reactive Messaging standards for robust, asynchronous communication in microservices architectures. 

Integrate Kafka with Open Liberty by following these steps:

1. <<#connection,Configure the Kafka broker connection>>
2. <<#define,Define channels for messaging>>
3. <<#includelib,Include Kafka client libraries>>
4. <<#consec,Configure security for the liberty-kafka connector>>

[#connection]
=== 1. Configure the Kafka broker connection

In the `microprofile-config.properties` file, specify the Kafka broker addresses to establish a connection, which indicates where your Kafka broker is hosted.
----
mp.messaging.connector.liberty-kafka.bootstrap.servers=myKafkaBroker:9092
----
By configuring a MicroProfile application as shown in the example, to connect to a Kafka broker at `myKafkaBroker:9092` for messaging. The application is able to send and receive messages through Kafka, facilitating event-driven communication.


[#define]
=== 2. Configuring microservices for Kafka messaging with Liberty-Kafka connector

To facilitate communication among applications, it is essential to configure microservices to send and receive messages through Kafka topics. Using the Liberty-Kafka connector, part of the MicroProfile Reactive Messaging specification, applications can connect to an Apache Kafka broker, ensuring efficient message handling for both incoming and outgoing channels.


==== Incoming message configuration

For receiving messages from a Kafka topic, configure an incoming channel by using the Liberty-Kafka connector. The setup includes specifying the Kafka topic from which messages are received, other settings such as the broker's address and consumer group ID for optimized message consumption.
----
mp.messaging.incoming.myChannel.connector=liberty-kafka
mp.messaging.incoming.myChannel.topic=myTopicName
mp.messaging.incoming.myChannel.bootstrap.servers=kafkabrokerhost:9092
mp.messaging.incoming.myChannel.group.id=myGroupID
mp.messaging.incoming.myChannel.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
mp.messaging.incoming.myChannel.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
----

The configuration ensures that your application connects to the specified Kafka topic (`myTopicName`) for incoming messages, with `kafkabrokerhost:9092` as the broker address and `myGroupID` as the consumer group ID. The deserializers are set to handle keys and values as strings.

To troubleshoot the Liberty-Kafka connector, address key issues like Kafka connectivity, managing multiple server instances, and giving distinct identifiers to producers and consumers. Make sure that the `bootstrap.servers` are configured correctly for connection. Each consumer has a distinct `group.id` to prevent conflicts, and producers need a distinct `client.id` to avoid identifier overlap.

If you start multiple instances of Open Liberty with the same application, you must assign a distinct `group.id` to each channel for every server instance. This requirement applies to all incoming channels. Without a distinct `group.id` on each server instance, the server will block any new connections to a topic after the first connection is established. This policy makes sure that each connection to a topic is distinct and properly managed across all server instances.

Deploying multiple applications with Kafka clients on Open Liberty to the same Kafka server can lead to identifier conflicts. Kafka assigns `client.id` to both producers and consumers, leading to this issue. Consumers also identify themselves using either their `group.id` or `client.id`. To avoid these conflicts, assigning a distinct `group.id` and `client.id` to each producer and consumer is crucial. Avoid directly setting these IDs on the Liberty-Kafka connector. Effective management of identifiers is crucial for successful Kafka integration with Open Liberty, facilitating smooth operations within the microservices architecture.


==== Outgoing message configuration

Similarly, for sending messages to a Kafka topic, an outgoing channel must be configured by using the Liberty-Kafka connector. The setup includes specifying the Kafka topic to which messages are sent, along with serialization for message keys and values.
----
mp.messaging.outgoing.myChannel.connector=liberty-kafka
mp.messaging.outgoing.myChannel.topic=myTopicName
mp.messaging.outgoing.myChannel.bootstrap.servers=kafkabrokerhost:9092
mp.messaging.outgoing.myChannel.key.serializer=org.apache.kafka.common.serialization.StringSerializer
mp.messaging.outgoing.myChannel.value.serializer=org.apache.kafka.common.serialization.StringSerializer
----

The configuration ensures messages are sent to the `myTopicName` Kafka topic, with the broker located at `kafkabrokerhost:9092`. Both message keys and values are serialized as strings for efficient transmission.

By setting up channels as demonstrated, you connect message channels directly to Kafka, offering precise control over the messaging channels. This enhances your application's scalability and robustness by efficiently managing messages, whether incoming or outgoing.

For more information, see xref:liberty-kafka-connector-channel-properties.adoc[Liberty-Kafka connector options and channel properties].

For more information, see link:/guides/microprofile-reactive-messaging.html#creating-the-consumer-in-the-inventory-microservice[Creating the consumer in the inventory microservice] in the Creating reactive Java microservices guide.

[#includelib]
=== 3. Include Kafka client libraries

To integrate Kafka into your application environment by using Open Liberty, choose one of the following methods.

* <<#kafkaappdep,Include Kafka libraries as an application dependency>> - Does not require any additional server configuration for permissions.
* <<#kafkashrddep,Include Kafka libraries as a shared library>> - Grant the necessary Java permissions for the libraries to function correctly.


[#kafkaappdep]
==== Include Kafka libraries as an application dependency

To use the Kafka connector provided by Open Liberty, you must include the Kafka client API jar in your application.

If you are building your application with Maven, add the Kafka client dependency in your Maven `pom.xml` file.

[source,XML]
----
<dependency>
    <groupId>org.apache.kafka</groupId>
    <artifactId>kafka-clients</artifactId>
    <version>3.5.1</version>
</dependency>
----

This approach integrates Kafka client libraries directly into your application. It does not require any additional server configuration for permissions, simplifying deployment and configuration management.

[#kafkashrddep]
==== Include Kafka libraries as a shared library

You can integrate Kafka client libraries as a shared resource within the Open Liberty server. This approach is useful for situations where several applications on the same server instance require the Kafka client libraries. It effectively minimizes duplication.

However, if Kafka client libraries are used as a xref:class-loader-library-config.adoc#shrdLib[shared library], you must explicitly grant the necessary Java permissions for the libraries to function correctly. These permissions allow the Kafka client to connect to Kafka brokers, read system properties, and access or modify security properties.

To configure these permissions, you can use the `server.xml` configuration file. The following example demonstrates how to grant the necessary permissions to a Kafka client library that is specified as a shared library:

[source,XML]
----
    <variable name="kafkaCodebase" value="${server.config.dir}/kafkaLib/kafka-clients-<client.version>.jar"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanServerPermission" name="createMBeanServer"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanPermission" name="*" actions="*"/>
   <javaPermission codebase="${kafkaCodebase}" className="javax.management.MBeanTrustPermission"name="register"/>
   
   <!-- Kafka client reads system properties -->
   <javaPermission codebase="${kafkaCodebase}" className="java.util.PropertyPermission"name="*"actions="read"/>
   
   <!-- Kafka client connects to the kafka broker server -->
   <javaPermission codebase="${kafkaCodebase}" className="java.net.SocketPermission"name="*"actions="connect"/>
   
   <!-- Kafka client loads serializers and deserializers by name -->
   <javaPermission codebase="${kafkaCodebase}" className="java.lang.RuntimePermission"name="getcodebase="${kafkaCodebase}" classLoader"actions="*"/>
   
   <!-- Kafka reads truststores -->
   <javaPermission codebase="${kafkaCodebase}" className="java.io.FilePermission" name="*" <!-- all files in the current directory (i.e. the server directory) --> actions="read"/>
   
   <!-- Kafka client allowed to invoke the Subject.doAs methods -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="doAs"/>
   
   <!-- Kafka client allowed to call getSubject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="getSubject"/>
   
   <!-- Kafka client sets properties for the Simple SASL/PLAIN Server Provider -->
   <javaPermission codebase="${kafkaCodebase}" className="java.security.SecurityPermission" name="putProviderProperty.Simple SASL/PLAIN Server Provider"/>
   
   <!-- Kafka client allowed to set a Provider -->
   <javaPermission codebase="${kafkaCodebase}" className="java.security.SecurityPermission" name="insertProvider"/>
   
   <!-- Kafka client allowed access to private Credentials belonging to a particular Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.PrivateCredentialPermission" name="* * "*"" actions="read"/>
   
   <!-- Kafka client allowed to modify the set of public credentials associated with a Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="modifyPublicCredentials"/>
   
   <!-- Kafka client allowed to modify the set of private credentials associated with a Subject -->
   <javaPermission codebase="${kafkaCodebase}" className="javax.security.auth.AuthPermission" name="modifyPrivateCredentials"/>
----

[#consec]
=== 4. Configure security for the liberty-kafka connector

For more information on security and authentication protocols, see xref:liberty-kafka-connector-config-security.adoc[Kafka connector security configuration].


For more information on Apache Kafka, see the https://kafka.apache.org/documentation.html#gettingStarted[Apache Kafka documentation].



